import React, { useState, useEffect, useCallback } from 'react';
import UserSetup from './components/UserSetup';
import ProgressSummary from './components/ProgressSummary';
import GameScreen from './components/GameScreen';
import StatisticsScreen from './components/StatisticsScreenGamified';
import LearningPathScreen from './components/LearningPathScreen';
import ModuleDetailScreen from './components/ModuleDetailScreen';
import * as api from './lib/api';
import { GameState, Session, User } from './types';
import { checkAndUpdateSeries, getCurrentDateString } from './lib/activitySeriesManager';

// Define google on the window object for TypeScript
declare global {
    interface Window {
        google: any;
    }
}

function App() {
    const [session, setSession] = useState<Session | null>(null);
    const [view, setView] = useState<'login' | 'summary' | 'game' | 'stats' | 'learningPath' | 'moduleDetail' | 'moduleGame'>('login');
    const [previousView, setPreviousView] = useState<'summary' | 'game'>('summary');
    const [isStarting, setIsStarting] = useState(true);
    const [selectedModuleId, setSelectedModuleId] = useState<string | null>(null);

    // –°–∫—Ä–æ–ª–ª –∫ –Ω–∞—á–∞–ª—É –ø—Ä–∏ —Å–º–µ–Ω–µ view
    useEffect(() => {
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
    }, [view]);

    useEffect(() => {
        const savedUserString = localStorage.getItem('ab-hero-user');
        if (savedUserString) {
            try {
                const savedUser: User = JSON.parse(savedUserString);
                handleLogin(savedUser);
            } catch (error) {
                console.error("Failed to parse saved user:", error);
                localStorage.removeItem('ab-hero-user'); // Clear corrupted data
                setIsStarting(false);
            }
        } else {
            setIsStarting(false);
        }
    }, []); 

    const handleLogin = useCallback(async (user: User, selectedLevel?: 'junior' | 'mid' | 'senior' | 'staff') => {
        console.log('üîµ handleLogin START', { user: user.email, selectedLevel });
        setIsStarting(true);
        
        try {
            localStorage.setItem('ab-hero-user', JSON.stringify(user));
            
            console.log('üîµ Fetching game state...');
            const existingState = await api.fetchGameState(user.email);
            console.log('üîµ Game state fetched:', existingState ? 'exists' : 'new user');

            if (existingState) {
                // Migrate old data: add ratingHistory if it doesn't exist
                if (!existingState.ratingHistory) {
                    existingState.ratingHistory = [0, existingState.rating];
                }
                // Migrate old data: add selectedDifficulty if it doesn't exist
                if (!existingState.selectedDifficulty) {
                    existingState.selectedDifficulty = 'junior';
                }
                // Migrate old data: add askedQuestionIds if it doesn't exist
                if (!existingState.askedQuestionIds) {
                    existingState.askedQuestionIds = [];
                }
                // Migrate old data: add levelProgress if it doesn't exist
                if (!existingState.levelProgress) {
                    console.log('üîÑ Migrating: Creating levelProgress');
                    const { QUESTION_DATABASE } = await import('./data/constants');
                    existingState.levelProgress = {
                        junior: {
                            askedQuestionIds: existingState.askedQuestionIds?.filter(id => 
                                QUESTION_DATABASE.find(q => q.id === id)?.seniority === 'junior'
                            ) || [],
                            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'junior').length,
                            averageScore: 0
                        },
                        mid: {
                            askedQuestionIds: existingState.askedQuestionIds?.filter(id => 
                                QUESTION_DATABASE.find(q => q.id === id)?.seniority === 'mid'
                            ) || [],
                            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'mid').length,
                            averageScore: 0
                        },
                        senior: {
                            askedQuestionIds: existingState.askedQuestionIds?.filter(id => 
                                QUESTION_DATABASE.find(q => q.id === id)?.seniority === 'senior'
                            ) || [],
                            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'senior').length,
                            averageScore: 0
                        },
                        staff: {
                            askedQuestionIds: existingState.askedQuestionIds?.filter(id => 
                                QUESTION_DATABASE.find(q => q.id === id)?.seniority === 'staff'
                            ) || [],
                            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'staff').length,
                            averageScore: 0
                        }
                    };
                    console.log('‚úÖ Migration complete:', existingState.levelProgress);
                } else {
                    console.log('‚úÖ levelProgress already exists:', existingState.levelProgress);
                }
                
                // Migrate old data: add questionAttempts if it doesn't exist
                if (!existingState.questionAttempts) {
                    console.log('üîÑ Migrating: Creating questionAttempts');
                    existingState.questionAttempts = [];
                }
                
                // Migrate: Sync rating with XP from questionAttempts
                if (existingState.questionAttempts && existingState.questionAttempts.length > 0) {
                    console.log('üîÑ Migrating: Syncing rating with actual XP from questionAttempts');
                    let calculatedRating = 0;
                    existingState.questionAttempts.forEach(attempt => {
                        calculatedRating += attempt.earnedXP ?? 0;
                    });
                    
                    // Only update if there's a mismatch
                    if (existingState.rating !== calculatedRating) {
                        console.log(`üîÑ Rating mismatch: ${existingState.rating} ‚Üí ${calculatedRating}`);
                        existingState.rating = calculatedRating;
                        
                        // Rebuild rating history from attempts
                        const newRatingHistory = [0];
                        let cumulative = 0;
                        existingState.questionAttempts.forEach(attempt => {
                            cumulative += attempt.earnedXP ?? 0;
                            newRatingHistory.push(cumulative);
                        });
                        existingState.ratingHistory = newRatingHistory;
                        console.log(`‚úÖ Rating synced: ${calculatedRating} XP`);
                    } else {
                        console.log(`‚úÖ Rating already in sync: ${calculatedRating} XP`);
                    }
                }
                
                // Migrate questionAttempts: add earnedXP if missing
                if (existingState.questionAttempts && existingState.questionAttempts.length > 0) {
                    const hasOldAttempts = existingState.questionAttempts.some(a => a.earnedXP === undefined);
                    if (hasOldAttempts) {
                        console.log('üîÑ Migrating: Adding earnedXP to questionAttempts');
                        const { calculateXP } = await import('./lib/xpCalculator');
                        existingState.questionAttempts = existingState.questionAttempts.map(attempt => {
                            if (attempt.earnedXP === undefined) {
                                const xpResult = calculateXP(attempt.feedback.overallScore, attempt.difficulty);
                                return { ...attempt, earnedXP: xpResult.earnedXP };
                            }
                            return attempt;
                        });
                        console.log('‚úÖ Migration complete: earnedXP added');
                    }
                }
                
                // –ù–û–í–û–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–µ—Ä–∏—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø—Ä–∏ –ª–æ–≥–∏–Ω–µ
                console.log('üî• Checking activity series...');
                const currentDate = getCurrentDateString();
                const { series, status, previousSeries } = checkAndUpdateSeries(existingState, currentDate);
                
                console.log('üî• Series status:', status, {
                    currentSeries: series.currentSeries,
                    previousSeries,
                    todayCompleted: series.todayCompleted
                });
                
                existingState.activitySeries = series;
                
                // TODO: –ü–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–∞–ª–∫—É –µ—Å–ª–∏ —Å–µ—Ä–∏—è –ø—Ä–µ—Ä–≤–∞–Ω–∞ (status === 'broken' && previousSeries > 3)
                // –≠—Ç–æ –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –≤ –≠—Ç–∞–ø–µ 3
                
                setSession({ user, gameState: existingState });
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º summary –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –æ—Ç–≤–µ—á–∞–ª –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã
                if (existingState.questionAttempts && existingState.questionAttempts.length > 0) {
                    setView('summary');
                } else {
                    setView('game');
                }
            } else {
                // –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
                // –ï—Å–ª–∏ —É—Ä–æ–≤–µ–Ω—å –µ—â–µ –Ω–µ –≤—ã–±—Ä–∞–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ (view –æ—Å—Ç–∞–µ—Ç—Å—è 'login')
                if (!selectedLevel) {
                    console.log('üîµ New user, waiting for level selection...');
                    setIsStarting(false);
                    return;
                }
                
                // –°–æ–∑–¥–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º —É—Ä–æ–≤–Ω–µ–º
                console.log('üîµ Creating new game state for new user...');
                const newGameState = api.createInitialGameState();
                console.log('üîµ Setting selected difficulty:', selectedLevel);
                newGameState.selectedDifficulty = selectedLevel;
                console.log('üîµ Setting session...');
                setSession({ user, gameState: newGameState });
                console.log('üîµ Setting view to game...');
                setView('game');
            }
            console.log('üîµ handleLogin COMPLETE');
        } catch (error) {
            console.error('‚ùå Error in handleLogin:', error);
            alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
        } finally {
            setIsStarting(false);
        }
    }, []);

    const handleLogout = useCallback(() => {
        // Important: disable auto sign-in for standard Google flow
        if (window.google) {
            window.google.accounts.id.disableAutoSelect();
        }
        localStorage.removeItem('ab-hero-user');
        setSession(null);
        setView('login');
    }, []);

    const handleReset = () => {
        if (session) {
            const newGameState = api.createInitialGameState();
            setSession({ ...session, gameState: newGameState });
            setView('game');
        }
    };

    const handleUpdateGameState = useCallback((newState: GameState) => {
        if (session) {
            const newSession = { ...session, gameState: newState };
            setSession(newSession);
            api.saveGameState(session.user.email, newState);
        }
    }, [session]);

    const renderContent = () => {
        if (isStarting && !session) {
             return <UserSetup onStart={()=>{}} isStarting={true} />;
        }

        switch (view) {
            case 'login':
                return <UserSetup onStart={handleLogin} isStarting={isStarting} />;
            case 'summary':
                if (!session) return null;
                return <ProgressSummary 
                            user={session.user} 
                            gameState={session.gameState} 
                            onContinue={() => setView('game')}
                            onReset={handleReset}
                            onShowStats={() => { setPreviousView('summary'); setView('stats'); }}
                        />;
            case 'game':
                if (!session) return null;
                return <GameScreen 
                            user={session.user} 
                            onLogout={handleLogout} 
                            gameState={session.gameState}
                            setGameState={handleUpdateGameState}
                            onShowStats={() => { setPreviousView('game'); setView('stats'); }}
                            onShowLearningPath={() => setView('learningPath')}
                       />;
            case 'moduleGame':
                if (!session || !selectedModuleId) return null;
                return <GameScreen 
                            user={session.user} 
                            onLogout={handleLogout} 
                            gameState={session.gameState}
                            setGameState={handleUpdateGameState}
                            onShowStats={() => { setPreviousView('moduleGame'); setView('stats'); }}
                            moduleFilter={selectedModuleId}
                            onExitModule={() => setView('moduleDetail')}
                       />;
            case 'stats':
                 if (!session) return null;
                 return <StatisticsScreen
                            user={session.user}
                            gameState={session.gameState}
                            onBack={() => setView(previousView)}
                        />
            case 'learningPath':
                if (!session) return null;
                return <LearningPathScreen
                            gameState={session.gameState}
                            onSelectModule={(moduleId) => {
                                setSelectedModuleId(moduleId);
                                setView('moduleDetail');
                            }}
                            onBack={() => setView('game')}
                        />
            case 'moduleDetail':
                if (!session || !selectedModuleId) return null;
                return <ModuleDetailScreen
                            gameState={session.gameState}
                            moduleId={selectedModuleId}
                            onBack={() => setView('learningPath')}
                            onStartQuestions={(moduleId) => {
                                setSelectedModuleId(moduleId);
                                setView('moduleGame');
                            }}
                        />
            default:
                return null;
        }
    };

    return renderContent();
}

export default App;