import { GameState, LevelProgress } from '../types';
import { CATEGORIES_CONFIG, KEY_POINT_TO_CATEGORY_MAP, QUESTION_DATABASE } from '../data/constants';
import { db } from '../config/firebase';
import { doc, getDoc, setDoc, collection, getDocs, query, orderBy, limit } from 'firebase/firestore';
import { initializeActivitySeries } from './activitySeriesManager';
import { initializeLearningProgress } from './learningPathManager';
import { initializeReferralSystem, processReferralLink } from './referralSystem';
import { truncateUserName } from '../utils/userUtils';
import { STORAGE_KEYS } from '../utils/constants';

const DB_KEY = STORAGE_KEYS.DATABASE;
const USE_FIREBASE = true; // Firebase –≤–∫–ª—é—á–µ–Ω

/**
 * Fetches game state from Firebase (with localStorage fallback)
 * @param email The user's email, used as a unique identifier.
 * @param currentUserName Optional current user name from Google OAuth to update if needed.
 * @returns A promise that resolves to the user's game state or null if not found.
 */
export const fetchGameState = async (email: string, currentUserName?: string): Promise<GameState | null> => {
    console.log(`[API] Fetching data for ${email}...`);
    
    // Try Firebase first
    if (USE_FIREBASE && db) {
        try {
            console.log('üîµ Trying to fetch from Firebase...');
            console.log('üîµ Firestore db object:', !!db);
            const docRef = doc(db, 'users', email);
            console.log('üîµ Document reference created:', docRef.path);
            const docSnap = await getDoc(docRef);
            console.log('üîµ Document snapshot exists:', docSnap.exists());

            if (docSnap.exists()) {
                console.log('‚úÖ Data loaded from Firebase');
                const data = docSnap.data() as GameState;
                console.log('‚úÖ Loaded data keys:', Object.keys(data));
                
                // –ú–ò–ì–†–ê–¶–ò–Ø: –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª—è –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
                if (!data.activitySeries) {
                    console.log('üîÑ Migrating: adding activitySeries');
                    data.activitySeries = initializeActivitySeries();
                }
                if (!data.inventory) {
                    console.log('üîÑ Migrating: adding inventory');
                    data.inventory = {
                        questionSkips: 0,
                        seriesProtection: 0
                    };
                }
                if (!data.completedDailyQuests) {
                    console.log('üîÑ Migrating: adding completedDailyQuests');
                    data.completedDailyQuests = [];
                }
                if (!data.learningProgress) {
                    console.log('üîÑ Migrating: adding learningProgress');
                    data.learningProgress = initializeLearningProgress();
                }
                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –∏–º—è –∏–∑ Google
                if (currentUserName && (!data.userName || data.userName !== currentUserName)) {
                    console.log(`üîÑ Updating userName: ${data.userName || 'none'} ‚Üí ${currentUserName}`);
                    data.userName = currentUserName;
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±—Ä–∞—Ç–Ω–æ –≤ Firebase
                    try {
                        const docRef = doc(db, 'users', email);
                        await setDoc(docRef, data, { merge: true });
                        console.log('‚úÖ userName updated and saved to Firebase');
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to save updated userName to Firebase:', error);
                    }
                }
                
                // Also save to localStorage as backup
                const localDb = localStorage.getItem(DB_KEY);
                const localData = localDb ? JSON.parse(localDb) : {};
                localData[email] = data;
                localStorage.setItem(DB_KEY, JSON.stringify(localData));
                
                return data;
            }
            console.log('‚ÑπÔ∏è No data in Firebase, checking localStorage...');
        } catch (error: any) {
            console.error('‚ùå Firebase fetch failed, falling back to localStorage:', error.message || error);
            console.error('‚ùå Full Firebase error:', error);
            // –ù–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É, –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ localStorage
        }
    }
    
    // Fallback to localStorage
    const dbString = localStorage.getItem(DB_KEY);
    if (!dbString) return null;
    const localDb = JSON.parse(dbString);
    return localDb[email] || null;
};

/**
 * Saves game state to Firebase (with localStorage backup)
 * @param email The user's email, used as a unique identifier.
 * @param gameState The current state of the game.
 * @param userName Optional user name to save in game state.
 * @returns A promise that resolves when the save is complete.
 */
export const saveGameState = async (email: string, gameState: GameState, userName?: string): Promise<void> => {
    console.log(`[API] Saving data for ${email}...`);
    
    // –í—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –æ–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω–æ
    const gameStateToSave = userName ? { ...gameState, userName } : gameState;
    
    // Always save to localStorage as backup
    const dbString = localStorage.getItem(DB_KEY);
    const localDb = dbString ? JSON.parse(dbString) : {};
    localDb[email] = gameStateToSave;
    localStorage.setItem(DB_KEY, JSON.stringify(localDb));
    
    // Try to save to Firebase
    if (USE_FIREBASE && db) {
        try {
            console.log('üîµ Trying to save to Firebase...');
            console.log('üîµ Firestore db object:', !!db);
            const docRef = doc(db, 'users', email);
            console.log('üîµ Document reference created:', docRef.path);
            console.log('üîµ Data to save:', gameStateToSave);
            await setDoc(docRef, gameStateToSave, { merge: true }); // merge: true –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª–µ–π
            console.log('‚úÖ Data saved to Firebase successfully');
        } catch (error: any) {
            console.error('‚ùå Firebase save failed (data saved to localStorage):', error.message || error);
            console.error('‚ùå Full error object:', error);
            // –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ - –¥–∞–Ω–Ω—ã–µ —É–∂–µ –≤ localStorage
        }
    } else {
        console.warn('‚ö†Ô∏è Firebase not available for saving:', { USE_FIREBASE, db: !!db });
    }
};

/**
 * Creates the initial state for a new game session.
 * @param userEmail - Email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞
 * @returns A fresh GameState object.
 */
export const createInitialGameState = (userEmail?: string): GameState => {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
    const levelProgress: Record<'junior' | 'mid' | 'senior' | 'staff', LevelProgress> = {
        junior: {
            askedQuestionIds: [],
            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'junior').length,
            averageScore: 0
        },
        mid: {
            askedQuestionIds: [],
            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'mid').length,
            averageScore: 0
        },
        senior: {
            askedQuestionIds: [],
            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'senior').length,
            averageScore: 0
        },
        staff: {
            askedQuestionIds: [],
            totalQuestions: QUESTION_DATABASE.filter(q => q.seniority === 'staff').length,
            averageScore: 0
        }
    };

    const gameState: GameState = {
        rating: 0,
        userName: userEmail || '', // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        categoryScores: Object.keys(CATEGORIES_CONFIG).reduce((acc, key) => {
            acc[key] = { totalScore: 0, count: 0 };
            return acc;
        }, {} as Record<string, { totalScore: number; count: number }>),
        keyPointScores: Object.keys(KEY_POINT_TO_CATEGORY_MAP).reduce((acc, key) => {
            acc[key] = { totalScore: 0, count: 0 };
            return acc;
        }, {} as Record<string, { totalScore: number; count: number }>),
        consecutiveGoodAnswersOnSimpleQuestions: 0,
        ratingHistory: [0],
        initialLevel: 'junior',
        selectedDifficulty: 'junior',
        levelProgress,
        questionAttempts: [],
        // –ù–û–í–´–ï –ü–û–õ–Ø:
        activitySeries: initializeActivitySeries(),
        inventory: {
            questionSkips: 0,
            seriesProtection: 0
        },
        completedDailyQuests: [],
        learningProgress: initializeLearningProgress()
    };
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é —Å–∏—Å—Ç–µ–º—É
    initializeReferralSystem(gameState, userEmail || 'User');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ pending —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥
    const pendingRefCode = localStorage.getItem('pendingReferralCode');
    if (pendingRefCode) {
        console.log('üìé –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞:', pendingRefCode);
        processReferralLink(gameState, pendingRefCode);
        localStorage.removeItem('pendingReferralCode');
    }
    
    return gameState;
};

/**
 * Processes referral reward when a new user registers via referral link
 * @param referrerEmail The email of the user who invited
 * @param referralEmail The email of the new user who was invited
 */
export const processReferralReward = async (referrerEmail: string, referralEmail: string): Promise<void> => {
  try {
    console.log(`üìé Processing referral: ${referralEmail} referred by ${referrerEmail}`);

    // –ü–æ–ª—É—á–∞–µ–º gameState –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ
    const referrerGameState = await fetchGameState(referrerEmail);
    if (!referrerGameState) {
      console.warn('‚ö†Ô∏è Referrer not found:', referrerEmail);
      return;
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é addReferral –∏–∑ referralSystem
    const { addReferral } = await import('./referralSystem');
    const { gameState: updatedGameState, rewards } = addReferral(referrerGameState, referralEmail);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–∏ –ª–∏ –Ω–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞–≥—Ä–∞–¥—ã (rewards - –æ–±—ä–µ–∫—Ç —Å xp, items –∏ —Ç.–¥.)
    if (rewards && (rewards.xp > 0 || (rewards.items && rewards.items.length > 0))) {
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π gameState –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ
      await saveGameState(referrerEmail, updatedGameState);
      console.log('‚úÖ Referral rewards processed:', rewards);
    }
  } catch (error) {
    console.error('‚ùå Error processing referral reward:', error);
  }
};

/**
 * Fetches all users from Firebase for leaderboard
 * @returns A promise that resolves to an array of user data with ratings
 */
export const fetchAllUsers = async (): Promise<Array<{ email: string; name: string; rating: number; ratingHistory?: number[] }>> => {
    console.log('[API] Fetching all users for leaderboard...');
    
    if (!USE_FIREBASE || !db) {
        console.log('‚ùå Firebase not available');
        return [];
    }
    
    try {
        const usersRef = collection(db, 'users');
        const q = query(usersRef, orderBy('rating', 'desc'), limit(100)); // Top 100 users
        const querySnapshot = await getDocs(q);
        
        const users: Array<{ email: string; name: string; rating: number; ratingHistory?: number[] }> = [];
        
        querySnapshot.forEach((doc) => {
            const data = doc.data() as GameState;
            
            if (data.rating > 0) { // Only include users with some progress
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ email
                const rawName = data.userName || doc.id;
                const displayName = truncateUserName(rawName);
                
                users.push({
                    email: doc.id,
                    name: displayName,
                    rating: data.rating,
                    ratingHistory: data.ratingHistory
                });
            }
        });
        
        console.log(`‚úÖ Fetched ${users.length} users from Firebase`);
        return users;
    } catch (error) {
        console.error('‚ùå Error fetching users:', error);
        return [];
    }
};